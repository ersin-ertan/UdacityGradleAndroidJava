task configTask00(description:"...", groupBy:"Config"){/*config closure*/}
task configTask01(description:"...", groupBy:"Config") << { println "the doLast"}
task configTask02{description "..."; groupBy 'Config'; doFirst{}}

task depend00{dependsOn configTask02}
task depend01{shouldRunBefore depend00}
task depend02{shouldRunAfter depend01}
task depend03{dependsOn = ['depend00', 'depend02']}
task depend04{dependsOn tasks.matching{task -> task.name.startsWith("config");}}
task depend05{mustRunAfter depend04; finalizedBy configTask00}

task Cop(type:Copy){from 'src/images'; into 'build/allImages'; exclude '*.png'}
task Del(type:Delete){delete 'src/images'; include '**/*.jpeg'}
task Zi(type:Zip){destinationDir = file('destinationDir')
baseName = 'myZipFile'
into 'zippedImageFolder'
from ('images'){include '*.jpg'; exclude 'backupJpgs/**'; into 'jpgs'} 
// no point of backupJpgs/** since just referencing backupJpgs would have the same funcitonality
from ('images'){include '*.png'; into 'pngs'}
}
task Unzi(type:Copy){
dependsOn = Zi
from zipTree('destinationDir/myZipFile.zip')
into 'destinationDir/unZippedFolder'}

// incremental builds state that if a file is unmodified, then it is not built and is seen as UP-TO-DATE, however modifiying a file, no matter what the dependencies will cause the gradle to build it again, while leaving unmodified files up to date


